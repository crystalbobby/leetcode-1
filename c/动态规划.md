动态规划把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存储在表格种，在求解大的问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率

# 什么问题可以使用动态规划
1. 最优子结构
   最优子结构性质是指问题的最优解包含其子问题的最优解。最优子结构是使用动态规划的最基本条件，如果不具有此性质，就不可以使用动态规划解决

2. 子问题重叠
   子问题重叠是指在求解子问题的过程中，有大量的子问题是重复的，那么只需要求解一次，然后把结果存储在表格中，以后使用时可以直接查询，不需要再次求解。子问题重叠不是使用动态规划的`必要条件`，但问题存在子问题重叠更能充分彰显动态规划的优势。

# 使用动态规划步骤
1. 寻找状态转移方程
2. 利用状态转移方程式自底向上求解问题


# 斐波那契数列


# [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
设函数F(N)表示走到第N级台阶走法的数量。
现在假设有10级台阶。现在就会出现两种情况：
1. 我们是从第9级，跨1级上来，到第10级
2. 我们是从第8级，跨2级上来，到第10级
其实对于任何第N级台阶，都会出现这两种情况，即第N级的前一步是走了1级或者两级。
所以如果我们统计F(10)的话，可以发现F(10) = F(9) + F(8)，即到第10级的走法等于到第9级的走法加上到第8级的走法。同理可得，F(9) = F(8) + F(7)，F(8) = F(7) + F(6)等等等等……

所以我们就得到了动态规划步骤1中的所说的所谓的`状态转移方程：F(N) = F(N-1) + F(N-2)`.
一直到最底层，当只有1级台阶时，F(1) = 1;当只有2级台阶时F(2) = 2.

# 最长上升子数列

# [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
给定一个整数数组 nums ，找到一个具有最大和的`连续子数组（子数组最少包含一个元素）`，返回其最大和。
> 示例:
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

假如我们现在站在第i个元素上，如何通过`第i个元素的值`和`前面若干个元素的值`来找到最大子序和呢？

假如我们现在有一个子序，它是最大子序的候选，我们就希望这个子序的后面是正数。
假如我们是一个元素，前面有一个子序，我们就希望这个子序的和是正的。

我们定义一个一个数组dp[], dp[i]表示`以第i个元素为结尾的一段最大子序和`。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int maxSubArray(int* nums, int numsSize){
    int *dp = malloc(sizeof(int)*(numsSize +1));
    dp[0] = nums[0];

    int max = dp[0];
    for (size_t i = 1; i < numsSize; i++)
    {
        if(dp[i-1] > 0)
            dp[i] = dp[i-1] + nums[i];
        else
            dp[i] = nums[i];

        if(dp[i] >= max)
            max = dp[i];
    }
    return max;
}

int main()
{
    int A[] = {-2,1,-3,4,-1,2,1,-5,4};
    printf("%d\n", maxSubArray(A, sizeof(A)/4));
}
```

# [打家劫舍](https://leetcode-cn.com/problems/house-robber/)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

假如小偷站在第i家的屋顶，偷还是不偷？
1. 如果偷这家，那前面的i-1家就不能偷，能偷到的的最大值就是i-2家的最大值加上这一家的钱
2. 如果不偷，当前偷到的最大值就是偷完i-1家的最大值

状态转移方程为: F(i) = max(F(i-2) + i, F(i-1))

定义一个数组dp[], dp[i]表示小偷从第1号到第i+1号屋子偷钱的最大收益

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int rob(int* nums, int numsSize){
    if(numsSize <= 0)
        return 0;
    
    if(numsSize == 1)
        return nums[0];
    
    int *dp = malloc(sizeof(int)*(numsSize));
    dp[0] = nums[0];
    dp[1] = nums[1] > nums[0] ? nums[1] : nums[0];

    for (size_t i = 2; i < numsSize; i++)
    {
        //状态转移方程为: F(i) = max(F(i-2) + i, F(i-1))
        dp[i] = dp[i-2]+nums[i] > dp[i-1] ? dp[i-2] + nums[i] : dp[i-1];
    }
    return dp[numsSize-1];
}

int main()
{
    int A[] = {1,2,3,1};
    printf("%d\n", rob(A, sizeof(A)/4));
}
```